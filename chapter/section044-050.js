export const QA044 = [
	["DB 구조, 데이터 형식, 접근 방식 등 DB를 구축하거나 수정할 목적으로 사용하는 언어", "데이터 정의어", "DDL", "Data Define Language"],
	["데이터 정의어(DDL)을 번역한 결과는 (\0\0\0)라는 특별한 파일에 여러 개의 테이블로 저장됨", "데이터 사전", "Data Dictionary"],
	["DDL의 3가지 유형 중 SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 정의하는 명령어", "CREATE"],
	["DDL의 3가지 유형 중 TABLE에 대한 정의를 변경하는 데 사용하는 명령어", "ALTER"],
	["DDL의 3가지 유형 중 SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 삭제하는 명령어", "DROP"],
	["스키마를 정의하는 명령문", "CREATE SCHEMA"],
	["스키마를 정의하는 명령문의 표기 형식은 \nCREATE SCHEMA 스키마명 (\0\0\0) 사용자_id; 이다.\n괄호 안에 들어갈 단어는?", "AUTHORIZATION"],
	["도메인을 정의하는 명령문", "CREATE DOMAIN"],
	["도메인을 정의하는 명령문의 표기 형식은 \nCREATE DOMAIN 도메인명 [AS] 데이터_타입 \n[(\0\0\0) 기본값] \n[CONSTRAINT 제약조건명 CHECK (범위값)]; 이다.\n괄호 안에 들어갈 단어는?", "DEFAULT"], 
	["도메인을 정의하는 명령문의 표기 형식은 \nCREATE DOMAIN 도메인명 [AS] 데이터_타입 \n[DEFAULT 기본값] \n[(\0\0\0) 제약조건명 CHECK (범위값)]; 이다. \n괄호 안에 들어갈 단어는?", "CONSTRAINT"],
	["테이블을 정의하는 명령문", "CREATE TABLE"],
	["테이블을 정의하는 명령문의 표기 형식은 \nCREATE TABLE 테이블명 (속성명 데이터 타입 \n[DEFAULT 기본값] [(\0\0\0)], ... \n[, PRIMARY KEY(기본키_속성명, ...)] \n[, UNIQUE(대체키_속성명, ...)] \n[, FOREIGN KEY(외래키_속성명, ...) REFERENCES 참조테이블(기본키_속성명, ...)] \n[ON DELETE 옵션] \n[ON UPDATE 옵션] \n[, CONSTRAINT 제약조건명] [CHECK (조건식)]); 이다. \n괄호 안에 들어갈 NULL을 허용하지 않겠다는 명령어는?", "NOT NULL"],
	["테이블을 정의하는 명령문의 표기 형식은 \nCREATE TABLE 테이블명 (속성명 데이터 타입 \n[DEFAULT 기본값] [NOT NULL], ... \n[, (\0\0\0)(기본키_속성명, ...)] \n[, UNIQUE(대체키_속성명, ...)] \n[, FOREIGN KEY(외래키_속성명, ...) REFERENCES 참조테이블(기본키_속성명, ...)] \n[ON DELETE 옵션] \n[ON UPDATE 옵션] \n[, CONSTRAINT 제약조건명] [CHECK (조건식)]); 이다. \n괄호 안에 들어갈 기본키로 사용할 속성을 지정하는 명령어는?", "PRIMARY KEY"],
	["테이블을 정의하는 명령문의 표기 형식은 \nCREATE TABLE 테이블명 (속성명 데이터 타입 \n[DEFAULT 기본값] [NOT NULL], ... \n[, PRIMARY KEY(기본키_속성명, ...)] \n[, (\0\0\0)(대체키_속성명, ...)] \n[, FOREIGN KEY(외래키_속성명, ...) REFERENCES 참조테이블(기본키_속성명, ...)] \n[ON DELETE 옵션] \n[ON UPDATE 옵션] \n[, CONSTRAINT 제약조건명] [CHECK (조건식)]); 이다. \n괄호 안에 들어갈 대체키로 사용할 속성을 지정하며, 중복된 값을 가질 수 없다는 속성을 지정하는 명령어는?", "UNIQUE"],
	["테이블을 정의하는 명령문의 표기 형식은 \nCREATE TABLE 테이블명 (속성명 데이터 타입 \n[DEFAULT 기본값] [NOT NULL], ... \n[, PRIMARY KEY(기본키_속성명, ...)] \n[, UNIQUE(대체키_속성명, ...)] \n[, (   ①   )(외래키_속성명, ...) (   ②   ) 참조테이블(기본키_속성명, ...)] \n[ON DELETE 옵션] \n[ON UPDATE 옵션] \n[, CONSTRAINT 제약조건명] [CHECK (조건식)]); 이다. \n괄호 안에 들어갈 외래키로 사용할 속성을 지정하는 명령어는?", "FOREIGN KEY, REFERENCES"],
	["테이블을 정의하는 명령문의 표기 형식은 \nCREATE TABLE 테이블명 (속성명 데이터 타입 \n[DEFAULT 기본값] [NOT NULL], ... \n[, PRIMARY KEY(기본키_속성명, ...)] \n[, UNIQUE(대체키_속성명, ...)] \n[, FOREIGN KEY(외래키_속성명, ...) REFERENCES 참조테이블(기본키_속성명, ...)] \n[(\0\0\0) 옵션] \n[ON UPDATE 옵션] \n[, CONSTRAINT 제약조건명] [CHECK (조건식)]); 이다. \n괄호 안에 들어갈 참조 테이블의 튜플이 삭제되었을 때 기본 테이블에 취해야 할 사항을 지정하는 명령어는?", "ON DELETE"],
	["테이블을 정의하는 명령문의 표기 형식은 \nCREATE TABLE 테이블명 (속성명 데이터 타입 \n[DEFAULT 기본값] [NOT NULL], ... \n[, PRIMARY KEY(기본키_속성명, ...)] \n[, UNIQUE(대체키_속성명, ...)] \n[, FOREIGN KEY(외래키_속성명, ...) REFERENCES 참조테이블(기본키_속성명, ...)] \n[ON DELETE 옵션] \n[(\0\0\0) 옵션] \n[, CONSTRAINT 제약조건명] [CHECK (조건식)]); 이다. \n괄호 안에 들어갈 참조 테이블의 참조 속성 값이 변경되었을 때 기본 테이블에 취해야 할 사항을 지정하는 명령어는?", "ON UPDATE"],
	["테이블을 정의하는 명령문의 표기 형식은 \nCREATE TABLE 테이블명 (속성명 데이터 타입 \n[DEFAULT 기본값] [NOT NULL], ... \n[, PRIMARY KEY(기본키_속성명, ...)] \n[, UNIQUE(대체키_속성명, ...)] \n[, FOREIGN KEY(외래키_속성명, ...) REFERENCES 참조테이블(기본키_속성명, ...)] \n[ON DELETE 옵션] \n[ON UPDATE 옵션] \n[, (\0\0\0) 제약조건명] [CHECK (조건식)]); 이다. \n괄호 안에 들어갈 제약 조건의 이름을 지정하는 명령어는?", "CONSTRAINT"],
	["테이블을 정의하는 명령문의 표기 형식은 \nCREATE TABLE 테이블명 (속성명 데이터 타입 \n[DEFAULT 기본값] [NOT NULL], ... \n[, PRIMARY KEY(기본키_속성명, ...)] \n[, UNIQUE(대체키_속성명, ...)] \n[, FOREIGN KEY(외래키_속성명, ...) REFERENCES 참조테이블(기본키_속성명, ...)] \n[ON DELETE 옵션] \n[ON UPDATE 옵션] \n[, CONSTRAINT 제약조건명] [(\0\0\0) (조건식)]); 이다. \n괄호 안에 들어갈 속성 값에 대한 제약 조건을 정의하는 명령어는?", "CHECK"],
	["뷰(View)를 정의하는 명령문", "CREATE VIEW"],
	["뷰(View)를 정의하는 명령문의 표기 형식은 \nCREATE VIEW 뷰명[(속성명[, 속성명, ...]) AS (\0\0\0)문; 이다. \n괄호 안에 들어갈 단어는?", "SELECT"],
	["인덱스를 정의하는 명령문", "CREATE INDEX"],
	["인덱스를 정의하는 명령문의 표기 형식은 \nCREATE [(\0\0\0)] INDEX 인덱스명 ON 테이블명(속성명 [ASC | DESC] [, 속성명 [ASC | DESC]]) [CLUSTER]; 이다. \n괄호 안에 들어갈 중복 값이 없는 속성으로 인덱스를 생성한다는 단어는?", "UNIQUE"],
	["인덱스를 정의하는 명령문의 표기 형식은 \nCREATE [UNIQUE] INDEX 인덱스명 ON 테이블명(속성명 [ASC | DESC] [, 속성명 [ASC | DESC]]) [(\0\0\0)]; 이다. \n괄호 안에 들어갈 인덱스가 클러스터드 인덱스로 설정되는 단어는?", "CLUSTER"],
	["테이블에 대한 정의를 변경하는 명령문", "ALTER TABLE"],
	["테이블에 대한 정의를 변경하는 명령문 중 새로운 속성(열)을 추가할 때 사용하는 명령문의 표기 형식은 \nALTER TABLE 테이블명 (\0\0\0) 속성명 데이터_타입 [DEFAULT '기본값']; 이다. \n괄호 안에 들어갈 단어는?", "ADD"],
	["테이블에 대한 정의를 변경하는 명령문 중 특정 속성의 Default 값을 변경할 때 사용하는 명령문의 표기 형식은 \nALTER TABLE 테이블명 (\0\0\0) 속성명 [SET DEFAULT '기본값']; 이다. \n괄호 안에 들어갈 단어는?", "ALTER"],
	["테이블에 대한 정의를 변경하는 명령문 중 특정 속성을 삭제할 때 사용하는 명령문의 표기 형식은 \nALTER TABLE 테이블명 (\0\0\0) 속성명 [CASCADE]; 이다. \n괄호 안에 들어갈 단어는?", "DROP COLUMN"],
	["스키마, 도메인, 기본 테이블, 뷰 테이블, 인덱스, 제약 조건 등을 제거하는 명령문", "DROP"]
];

export const QA045 = [
  ["데이터의 보안, 무결성, 회복, 병행 제어 등을 정의하는 데 사용하는 언어", "데이터 제어어", "DCL", "Data Control Language"],
  ["데이터베이스 관리자(DBA)가 데이터 관리를 목적으로 사용하는 언어", "데이터 제어어", "DCL", "Data Control Language"],
  ["데이터 제어어(DCL)의 종류 중 명령에 의해 수행된 결과를 실제 물리적 디스크로 저장하고, 데이터베이스 조작 작업이 정상적으로 완료되었음을 관리자에게 알려주는 명령어", "COMMIT"],
  ["데이터 제어어(DCL)의 종류 중 트랜잭션 처리가 정상적으로 완료된 후 트랜책션이 수행한 내용을 데이터베이스에 반영하는 명령어", "COMMIT"],
  ["데이터 제어어(DCL)의 종류 중 데이터베이스 조작 작업이 비정상적으로 종료되었을 때 원래의 상태로 복구하는 명령어", "ROLLBACK"],
  ["데이터 제어어(DCL)의 종류 중 변경되었으나 아직 COMMIT 되지 않은 모든 내용들을 취소하고 데이터베이스를 이전 상태로 되돌리는 명령어", "ROLLBACK"],
  ["데이터 제어어(DCL)의 종류 중 데이터베이스 관리자가 데이터베이스 사용자에게 사용 권한을 부여하는 명령어", "GRANT"],
  ["데이터 제어어(DCL)의 종류 중 데이터베이스 관리자가 데이터베이스 사용자의 사용 권한을 취소하는 명령어", "REVOKE"],
  ["사용자등급을 지정 및 해제할 때 사용자등급 중 데이터베이스 관리자를 의미하는 용어는?", "DBA"],
  ["사용자등급을 지정 및 해제할 때 사용자등급 중 데이터베이스 및 테이블 생성 가능자를 의미하는 용어는?", "RESOURCE"],
  ["사용자등급을 지정 및 해제할 때 사용자등급 중 단순 사용자를 의미하는 용어는?", "CONNECT"],
  ["사용자등급을 지정하는 표기 형식은 \nGRANT 사용자등급 TO 사용자_ID_리스트 [IDENTIFIED BY 암호]; 이다. \n괄호 안에 들어갈 단어는?", "GRANT"],
  ["사용자등급을 지정하는 표기 형식은 \nGRANT 사용자등급 (\0\0\0) 사용자_ID_리스트 [IDENTIFIED BY 암호]; 이다. \n괄호 안에 들어갈 단어는?", "TO"],
  ["사용자등급을 지정하는 표기 형식은 \nGRANT 사용자등급 TO 사용자_ID_리스트 [(\0\0\0) 암호]; 이다. \n괄호 안에 들어갈 단어는?", "IDENTIFIED BY"],
  ["사용자등급을 해제하는 표기 형식은 \n(\0\0\0) 사용자등급 FROM 사용자_ID_리스트; 이다. \n괄호 안에 들어갈 단어는?", "REVOKE"],
  ["사용자등급을 해제하는 표기 형식은 \nREVOKE 사용자등급 (\0\0\0) 사용자_ID_리스트; 이다. \n괄호 안에 들어갈 단어는?", "FROM"],
  ["테이블 및 속성에 대한 권한을 부여하는 표기 형식은 \n(\0\0\0) 권한_리스트 ON 개체 TO 사용자 [WITH GRANT OPTION]; 이다. \n괄호 안에 들어갈 단어는?", "GRANT"],
  ["테이블 및 속성에 대한 권한을 부여하는 표기 형식은 \nGRANT 권한_리스트 (\0\0\0) 개체 TO 사용자 [WITH GRANT OPTION]; 이다. \n괄호 안에 들어갈 단어는?", "ON"],
  ["테이블 및 속성에 대한 권한을 부여하는 표기 형식은 \nGRANT 권한_리스트 ON 개체 (\0\0\0) 사용자 [WITH GRANT OPTION]; 이다. \n괄호 안에 들어갈 단어는?", "TO"],
  ["테이블 및 속성에 대한 권한을 부여하는 표기 형식은 \nGRANT 권한_리스트 ON 개체 TO 사용자 [(\0\0\0)]; 이다. \n괄호 안에 들어갈 부여받은 권한을 다른 사용자에게 다시 부여할 수 있는 권한을 부여한다는 단어는?", "WITH GRANT OPTION"],
  ["테이블 및 속성에 대한 권한을 취소하는 표기 형식은 \n(\0\0\0) [GRANT OPTION FOR] 권한_리스트 ON 개체 FROM 사용자 [CASCADE]; 이다. \n괄호 안에 들어갈 단어는?", "REVOKE"],
  ["테이블 및 속성에 대한 권한을 취소하는 표기 형식은 \nREVOKE [(\0\0\0)] 권한_리스트 ON 개체 FROM 사용자 [CASCADE]; 이다. \n괄호 안에 들어갈 다른 사용자에게 권한을 부여할 수 있는 권한을 취소하는 단어는?", "GRANT OPTION FOR"],
  ["테이블 및 속성에 대한 권한을 취소하는 표기 형식은 \nREVOKE [GRANT OPTION FOR] 권한_리스트 (\0\0\0) 개체 FROM 사용자 [CASCADE]; 이다. \n괄호 안에 들어갈 단어는?", "ON"],
  ["테이블 및 속성에 대한 권한을 취소하는 표기 형식은 \nREVOKE [GRANT OPTION FOR] 권한_리스트 ON 개체 (\0\0\0) 사용자 [CASCADE]; 이다. \n괄호 안에 들어갈 단어는?", "FROM"],
  ["테이블 및 속성에 대한 권한을 취소하는 표기 형식은 \nREVOKE [GRANT OPTION FOR] 권한_리스트 ON 개체 FROM 사용자 [(\0\0\0)]; 이다. \n괄호 안에 들어갈 권한 취소 시 권한을 부여받았던 사용자가 다른 사용자에게 부여한 권한도 연쇄적으로 취소하는 단어는?", "CASCADE"],
  ["트랜잭션 내에 ROLLBACK 할 위치로 저장점을 지정하는 명령어", "SAVEPOINT"]
];

export const QA046 = [
  ["데이터베이스 사용자가 저장된 데이터를 실질적으로 관리하는데 사용되는 언어", "데이터 조작어", "DML", "Data Manipulation Language"],
  ["데이터 조작어(DML)의 유형 중 테이블에서 튜플을 검색하는 명령문", "SELECT"],
  ["데이터 조작어(DML)의 유형 중 테이블에 새로운 튜플을 삽입하는 명령문", "INSERT"],
  ["데이터 조작어(DML)의 유형 중 테이블에서 튜플을 삭제하는 명령문", "DELETE"],
  ["데이터 조작어(DML)의 유형 중 테이블에서 튜플의 내용을 갱신하는 명령문", "UPDATE"],
  ["기본 테이블에 새로운 튜플을 삽입할 때 사용하는 삽입문의 일반 형식은 \n(\0\0\0) INTO 테이블명([속성명1, 속성명2, ...]) \nVALUES (데이터1, 데이터2, ...); 이다. \n괄호 안에 들어갈 단어는?", "INSERT"],
  ["기본 테이블에 새로운 튜플을 삽입할 때 사용하는 삽입문의 일반 형식은 \nINSERT (\0\0\0) 테이블명([속성명1, 속성명2, ...]) \nVALUES (데이터1, 데이터2, ...); 이다. \n괄호 안에 들어갈 단어는?", "INTO"],
  ["기본 테이블에 새로운 튜플을 삽입할 때 사용하는 삽입문의 일반 형식은 \nINSERT INTO 테이블명([속성명1, 속성명2, ...]) \n(\0\0\0) (데이터1, 데이터2, ...); 이다. \n괄호 안에 들어갈 단어는?", "VALUES"],
  ["기본 테이블에 있는 튜플들 중에서 특정 튜플(행)을 삭제할 때 사용하는 삭제문의 일반 형식은 \n(\0\0\0) FROM 테이블명 [WHERE 조건]; 이다. \n괄호 안에 들어갈 단어는?", "DELETE"],
  ["기본 테이블에 있는 튜플들 중에서 특정 튜플(행)을 삭제할 때 사용하는 삭제문의 일반 형식은 \nDELETE (\0\0\0) 테이블명 [WHERE 조건]; 이다. \n괄호 안에 들어갈 단어는?", "FROM"],
  ["기본 테이블에 있는 튜플들 중에서 특정 튜플(행)을 삭제할 때 사용하는 삭제문의 일반 형식은 \nDELETE FROM 테이블명 [(\0\0\0) 조건]; 이다. \n괄호 안에 들어갈 단어는?", "WHERE"],
  ["기본 테이블에 있는 튜플들 중에서 특정 튜플의 내용을 변경할 때 사용하는 갱신문의 일반 형식은 \n(\0\0\0) 테이블명 \nSET 속성명 = 데이터[, 속성명=데이터, ...] \n[WHERE 조건]; 이다. \n괄호 안에 들어갈 단어는?", "UPDATE"],
  ["기본 테이블에 있는 튜플들 중에서 특정 튜플의 내용을 변경할 때 사용하는 갱신문의 일반 형식은 \nUPDATE 테이블명 \n(\0\0\0) 속성명 = 데이터[, 속성명=데이터, ...] \n[WHERE 조건]; 이다. \n괄호 안에 들어갈 단어는?", "SET"],
  ["기본 테이블에 있는 튜플들 중에서 특정 튜플의 내용을 변경할 때 사용하는 갱신문의 일반 형식은 \nUPDATE 테이블명 \nSET 속성명 = 데이터[, 속성명=데이터, ...] \n[(     ) 조건]; 이다. \n괄호 안에 들어갈 단어는?", "WHERE"]
];

export const QA047 = [
  ["SELECT문의 일반 형식은 \nSELECT [(\0\0\0)] [테이블명.]속성명 [AS 별칭][, [테이블명.]속성명, ...] \n[, 그룹함수(속성명) [AS 별칭]] \n[, Windows함수 OVER (PARTITION BY 속성명1, 속성명2, ... \n\0\0\0ORDER BY 속성명3, 속성명4, ...)] \nFROM 테이블명[, 테이블명, ...] \n[WHERE 조건] \n[GROUP BY 속성명, 속성명, ...] \n[HAVING 조건] \n[ORDER BY 속성명 [ASC | DESC]]; 이다. \n괄호 안에 들어갈 검색할 튜플 수를 제한하는 명령어를 기술할 때 쓰는 단어는?", "PREDICATE"],
  ["SELECT문의 일반 형식은 \nSELECT [(\0\0\0)] [테이블명.]속성명 [AS 별칭][, [테이블명.]속성명, ...] \n[, 그룹함수(속성명) [AS 별칭]] \n[, Windows함수 OVER (PARTITION BY 속성명1, 속성명2, ... \n\0\0\0ORDER BY 속성명3, 속성명4, ...)] \nFROM 테이블명[, 테이블명, ...] \n[WHERE 조건] \n[GROUP BY 속성명, 속성명, ...] \n[HAVING 조건] \n[ORDER BY 속성명 [ASC | DESC]]; 이다. \n괄호 안에 들어갈 중복된 튜플이 있으면 그 중 첫 번째 한 개만 표시한다는 단어는?", "DISTINCT"],
  ["SELECT문의 일반 형식은 \nSELECT [PREDICATE] [테이블명.]속성명 [(\0\0\0) 별칭][, [테이블명.]속성명, ...] \n[, 그룹함수(속성명) [AS 별칭]] \n[, Windows함수 OVER (PARTITION BY 속성명1, 속성명2, ... \n\0\0\0ORDER BY 속성명3, 속성명4, ...)] \nFROM 테이블명[, 테이블명, ...] \n[WHERE 조건] \n[GROUP BY 속성명, 속성명, ...] \n[HAVING 조건] \n[ORDER BY 속성명 [ASC | DESC]]; 이다. \n괄호 안에 들어갈 속성이나 연산의 이름을 다른 이름으로 표시하기 위해 사용하는 단어는?", "AS"],
  ["SELECT문의 일반 형식은 \nSELECT [PREDICATE] [테이블명.]속성명 [AS 별칭][, [테이블명.]속성명, ...] \n[, 그룹함수(속성명) [AS 별칭]] \n[, Windows함수 OVER (PARTITION BY 속성명1, 속성명2, ... \n\0\0\0ORDER BY 속성명3, 속성명4, ...)] \n(\0\0\0) 테이블명[, 테이블명, ...] \n[WHERE 조건] \n[GROUP BY 속성명, 속성명, ...] \n[HAVING 조건] \n[ORDER BY 속성명 [ASC | DESC]]; 이다. \n괄호 안에 들어갈 검색할 데이터가 들어있는 테이블 이름을 기술하는 단어는?", "FROM"],
  ["SELECT문의 일반 형식은 \nSELECT [PREDICATE] [테이블명.]속성명 [AS 별칭][, [테이블명.]속성명, ...] \n[, 그룹함수(속성명) [AS 별칭]] \n[, Windows함수 OVER (PARTITION BY 속성명1, 속성명2, ... \n\0\0\0ORDER BY 속성명3, 속성명4, ...)] \nFROM 테이블명[, 테이블명, ...] \n[(\0\0\0) 조건] \n[GROUP BY 속성명, 속성명, ...] \n[HAVING 조건] \n[ORDER BY 속성명 [ASC | DESC]]; 이다. \n괄호 안에 들어갈 검색할 조건을 기술할 때 쓰는 단어는?",  "WHERE"],
  ["SELECT문의 일반 형식은 \nSELECT [PREDICATE] [테이블명.]속성명 [AS 별칭][, [테이블명.]속성명, ...] \n[, 그룹함수(속성명) [AS 별칭]] \n[, Windows함수 OVER (PARTITION BY 속성명1, 속성명2, ... \n\0\0\0ORDER BY 속성명3, 속성명4, ...)] \nFROM 테이블명[, 테이블명, ...] \n[WHERE 조건] \n[GROUP BY 속성명, 속성명, ...] \n[HAVING 조건] \n[(\0\0\0) 속성명 [ASC | DESC]]; 이다. \n괄호 안에 들어갈 데이터를 정렬하여 검색할 때 사용하는 단어는?", "ORDER BY"],
  ["대표 문자를 이용해 지정된 속성의 값이 문자 패턴과 일치하는 튜플을 검색하기 위해 사용되는 연산자는?", "LIKE", "LIKE 연산자"],
  ["LIKE 연산자의 대표 문자 중 모든 문자를 대표하는 문자는?", "%"],
  ["LIKE 연산자의 대표 문자 중 문자 하나를 대표하는 문자는?", "_"],
  ["LIKE 연산자의 대표 문자 중 숫자 하나를 대표하는 문자는?", "#"],
  ["조건절에 주어진 질의를 먼저 수행하여 그 검색 결과를 조건절의 피연산자로 사용하는 질의는?", "하위 질의"],
  ["NULL이 아닌 값을 검색할 때 쓰는 에약어", "IS NOT NULL"],
  ["하위 질의로 검색된 결과가 존재하는지 확인할 때 사용하는 예약어", "EXISTS"]
];

export const QA048 = [
  ["SELECT문의 일반 형식은 \nSELECT [PREDICATE] [테이블명.]속성명 [AS 별칭][, [테이블명.]속성명, ...] \n[, (\0\0\0)(속성명) [AS 별칭]] \n[, Windows함수 OVER (PARTITION BY 속성명1, 속성명2, ... \n\0\0\0ORDER BY 속성명3, 속성명4, ...)] \nFROM 테이블명[, 테이블명, ...] \n[WHERE 조건] \n[GROUP BY 속성명, 속성명, ...] \n[HAVING 조건] \n[ORDER BY 속성명 [ASC | DESC]]; 이다. 괄호 안에 들어갈 GROUP BY절에 지정된 그룹별 튜플 수를 구하는 함수는?", "COUNT"],
  ["SELECT문의 일반 형식은 \nSELECT [PREDICATE] [테이블명.]속성명 [AS 별칭][, [테이블명.]속성명, ...] \n[, (\0\0\0)(속성명) [AS 별칭]] \n[, Windows함수 OVER (PARTITION BY 속성명1, 속성명2, ... \n\0\0\0ORDER BY 속성명3, 속성명4, ...)] \nFROM 테이블명[, 테이블명, ...] \n[WHERE 조건] \n[GROUP BY 속성명, 속성명, ...] \n[HAVING 조건] \n[ORDER BY 속성명 [ASC | DESC]]; 이다. 괄호 안에 들어갈 GROUP BY절에 지정된 그룹별 합계를 구하는 함수는?", "SUM"],
  ["SELECT문의 일반 형식은 \nSELECT [PREDICATE] [테이블명.]속성명 [AS 별칭][, [테이블명.]속성명, ...] \n[, (\0\0\0)(속성명) [AS 별칭]] \n[, Windows함수 OVER (PARTITION BY 속성명1, 속성명2, ... \n\0\0\0ORDER BY 속성명3, 속성명4, ...)] \nFROM 테이블명[, 테이블명, ...] \n[WHERE 조건] \n[GROUP BY 속성명, 속성명, ...] \n[HAVING 조건] \n[ORDER BY 속성명 [ASC | DESC]]; 이다. 괄호 안에 들어갈 GROUP BY절에 지정된 그룹별 평균을 구하는 함수는?", "AGE"],
  ["SELECT문의 일반 형식은 \nSELECT [PREDICATE] [테이블명.]속성명 [AS 별칭][, [테이블명.]속성명, ...] \n[, (\0\0\0)(속성명) [AS 별칭]] \n[, Windows함수 OVER (PARTITION BY 속성명1, 속성명2, ... \n\0\0\0ORDER BY 속성명3, 속성명4, ...)] \nFROM 테이블명[, 테이블명, ...] \n[WHERE 조건] \n[GROUP BY 속성명, 속성명, ...] \n[HAVING 조건] \n[ORDER BY 속성명 [ASC | DESC]]; 이다. 괄호 안에 들어갈 GROUP BY절에 지정된 그룹별 최대값을 구하는 함수는?", "MAX"],
  ["SELECT문의 일반 형식은 \nSELECT [PREDICATE] [테이블명.]속성명 [AS 별칭][, [테이블명.]속성명, ...] \n[, (\0\0\0)(속성명) [AS 별칭]] \n[, Windows함수 OVER (PARTITION BY 속성명1, 속성명2, ... \n\0\0\0ORDER BY 속성명3, 속성명4, ...)] \nFROM 테이블명[, 테이블명, ...] \n[WHERE 조건] \n[GROUP BY 속성명, 속성명, ...] \n[HAVING 조건] \n[ORDER BY 속성명 [ASC | DESC]]; 이다. 괄호 안에 들어갈 GROUP BY절에 지정된 그룹별 최소값을 구하는 함수는?", "MIN"],
  ["SELECT문의 일반 형식은 \nSELECT [PREDICATE] [테이블명.]속성명 [AS 별칭][, [테이블명.]속성명, ...] \n[, (\0\0\0)(속성명) [AS 별칭]] \n[, Windows함수 OVER (PARTITION BY 속성명1, 속성명2, ... \n\0\0\0ORDER BY 속성명3, 속성명4, ...)] \nFROM 테이블명[, 테이블명, ...] \n[WHERE 조건] \n[GROUP BY 속성명, 속성명, ...] \n[HAVING 조건] \n[ORDER BY 속성명 [ASC | DESC]]; 이다. 괄호 안에 들어갈 GROUP BY절에 지정된 그룹별 표준편차를 구하는 함수는?", "STDDEV"],
  ["SELECT문의 일반 형식은 \nSELECT [PREDICATE] [테이블명.]속성명 [AS 별칭][, [테이블명.]속성명, ...] \n[, (\0\0\0)(속성명) [AS 별칭]] \n[, Windows함수 OVER (PARTITION BY 속성명1, 속성명2, ... \n\0\0\0ORDER BY 속성명3, 속성명4, ...)] \nFROM 테이블명[, 테이블명, ...] \n[WHERE 조건] \n[GROUP BY 속성명, 속성명, ...] \n[HAVING 조건] \n[ORDER BY 속성명 [ASC | DESC]]; 이다. 괄호 안에 들어갈 GROUP BY절에 지정된 그룹별 분산을 구하는 함수는?", "VARIANCE"],
  ["SELECT문의 일반 형식은 \nSELECT [PREDICATE] [테이블명.]속성명 [AS 별칭][, [테이블명.]속성명, ...] \n[, (\0\0\0)(속성명) [AS 별칭]] \n[, Windows함수 OVER (PARTITION BY 속성명1, 속성명2, ... \n\0\0\0ORDER BY 속성명3, 속성명4, ...)] \nFROM 테이블명[, 테이블명, ...] \n[WHERE 조건] \n[GROUP BY 속성명, 속성명, ...] \n[HAVING 조건] \n[ORDER BY 속성명 [ASC | DESC]]; 이다. 괄호 안에 들어갈 GROUP BY절에 지정된 그룹별 소계 구하는 함수이자 하위 레벨에서 상위 레벨 순으로 데이터가 집계되는 함수는?", "ROLLUP"],
  ["SELECT문의 일반 형식은 \nSELECT [PREDICATE] [테이블명.]속성명 [AS 별칭][, [테이블명.]속성명, ...] \n[, (\0\0\0)(속성명) [AS 별칭]] \n[, Windows함수 OVER (PARTITION BY 속성명1, 속성명2, ... \n\0\0\0ORDER BY 속성명3, 속성명4, ...)] \nFROM 테이블명[, 테이블명, ...] \n[WHERE 조건] \n[GROUP BY 속성명, 속성명, ...] \n[HAVING 조건] \n[ORDER BY 속성명 [ASC | DESC]]; 이다. 괄호 안에 들어갈 GROUP BY절에 지정된 그룹별 소계 구하는 함수이자 상위 레벨에서 하위 레벨 순으로 데이터가 집계되는 함수는?", "CUBE"],
  ["SELECT문의 일반 형식은 \nSELECT [PREDICATE] [테이블명.]속성명 [AS 별칭][, [테이블명.]속성명, ...] \n[, 그룹함수(속성명) [AS 별칭]] \n[, (\0\0\0) OVER (PARTITION BY 속성명1, 속성명2, ... \n\0\0\0ORDER BY 속성명3, 속성명4, ...)] \nFROM 테이블명[, 테이블명, ...] \n[WHERE 조건] \n[GROUP BY 속성명, 속성명, ...] \n[HAVING 조건] \n[ORDER BY 속성명 [ASC | DESC]]; 이다. 괄호 안에 들어갈 윈도우별로 각 레코드에 대한 일련번호를 반환하는 WINDOW 함수는?", "ROW NUMBER()"],
  ["SELECT문의 일반 형식은 \nSELECT [PREDICATE] [테이블명.]속성명 [AS 별칭][, [테이블명.]속성명, ...] \n[, 그룹함수(속성명) [AS 별칭]] \n[, (\0\0\0) OVER (PARTITION BY 속성명1, 속성명2, ... \n\0\0\0ORDER BY 속성명3, 속성명4, ...)] \nFROM 테이블명[, 테이블명, ...] \n[WHERE 조건] \n[GROUP BY 속성명, 속성명, ...] \n[HAVING 조건] \n[ORDER BY 속성명 [ASC | DESC]]; 이다. 괄호 안에 들어갈 윈도우별로 순위를 반환하며, 공동 순위를 반영하는 WINDOW 함수는?", "RANK()"],
  ["SELECT문의 일반 형식은 \nSELECT [PREDICATE] [테이블명.]속성명 [AS 별칭][, [테이블명.]속성명, ...] \n[, 그룹함수(속성명) [AS 별칭]] \n[, (\0\0\0) OVER (PARTITION BY 속성명1, 속성명2, ... \n\0\0\0ORDER BY 속성명3, 속성명4, ...)] \nFROM 테이블명[, 테이블명, ...] \n[WHERE 조건] \n[GROUP BY 속성명, 속성명, ...] \n[HAVING 조건] \n[ORDER BY 속성명 [ASC | DESC]]; 이다. 괄호 안에 들어갈 윈도우별로 순위를 반환하며, 공동 순위를 무시하고 순위를 부여하는 함수는?", "DENSE_RANK()"],
  ["집합 연산자를 사용하여 2개 이상의 테이블의 데이터를 하나로 통합하는 질의", "통합 질의"],
  ["통합 질의의 표기 형식은 \nSELECT 속성명1, 속성명2, ... \nFROM 테이블명 \n(\0\0\0) \nSELECT 속성명1, 속성명2, ... \nFROM 테이블명 \n[ORDER BY 속성명 [ASC | DESC]]; 이다. \n괄호 안에 들어갈 두 SELECT문의 조회 결과를 통합하고, 중복된 행은 한 번만 출력하는 집합 연산자는?", "UNION"],
  ["통합 질의의 표기 형식은 \nSELECT 속성명1, 속성명2, ... \nFROM 테이블명 \n(\0\0\0) \nSELECT 속성명1, 속성명2, ... \nFROM 테이블명 \n[ORDER BY 속성명 [ASC | DESC]]; 이다. \n괄호 안에 들어갈 두 SELECT문의 조회 결과를 통합하고, 중복된 행도 모두 그대로 출력하는 집합 연산자는?", "UNION ALL"],
  ["통합 질의의 표기 형식은 \nSELECT 속성명1, 속성명2, ... \nFROM 테이블명 \n(\0\0\0) \nSELECT 속성명1, 속성명2, ... \nFROM 테이블명 \n[ORDER BY 속성명 [ASC | DESC]]; 이다. \n괄호 안에 들어갈 두 SELECT문의 조회 결과 중 공통된 행만 출력하는 집합 연산자는?", "INTERSECT"]
];

export const QA049 = [
  ["2개의 릴레이션에서 연관된 튜플들을 결합하여, 하나의 새로운 릴레이션을 반환하는 것", "JOIN"],
  ["일반적으로 EQUI JOIN과 NON-EQUI JOIN으로 구분되며 조건이 없을 경우 CROSS JOIN과 동일한 결과를 얻을 수 있는 JOIN은?", "INNER JOIN"],
  ["(     )절을 이용한 EQUI JOIN의 표기 형식은 \nSELECT [테이블명1.]속성명, [테이블명2.]속성명, ... \nFROM 테이블명1, 테이블명2, ... \n(     ) 테이블명1.속성명 = 테이블명2.속성명; 이다.\n 괄호 안에 들어갈 단어는?", "WHERE"],
  ["(     )절을 이용한 EQUI JOIN의 표기 형식은 \nSELECT [테이블명1.]속성명, [테이블명2.]속성명, ... \nFROM 테이블명1 (     ) 테이블명2; 이다. \n괄호 안에 들어갈 단어는?", "NATURAL JOIN"],
  ["JOIN ~ (     )절을 이용한 EQUI JOIN의 표기 형식은 \nSELECT [테이블명1.]속성명, [테이블명2.]속성명, ... \nFROM 테이블명1 JOIN 테이블명2 (     )(속성명); 이다. \n괄호 안에 들어갈 단어는?", "USING"],
  ["JOIN 조건에 '=' 조건이 아닌 나머지 비교 연산자, 즉 >, <, <>, >=, <= 연산자를 사용하는 JOIN 방법", "NON-EQUI JOIN"],
  ["NON-EQUI JOIN의 표기 형식은 \nSELECT [테이블명1.]속성명, [테이블명2.]속성명, ... \nFROM 테이블명1, 테이블명2, ... \n(     ) (NON-EQUI JOIN 조건); 이다. \n괄호 안에 들어갈 단어는?", "WHERE"],
  ["JOIN 조건에 만족하지 않는 튜플도 결과로 출력하기 위한 JOIN 방법으로, LEFT (     ), RIGHT (     ), FULL (     )이 있다. 괄호 안에 들어갈 단어는?", "OUTER JOIN"],
  ["INNER JOIN의 결과를 구한 후 우측 항 릴레이션의 어떤 튜플과도 맞지 않는 좌측 항의 릴레이션에 있는 튜플들에 NULL 값을 붙여서 INNER JOIN의 결과에 추가하는 JOIN 방법은?", "LEFT OUTER JOIN"],
  ["LEFT OUTER JOIN의 표기 형식은 \nSELECT [테이블명1.]속성명, [테이블명2.]속성명, ... \nFROM 테이블명1 LEFT OUTER JOIN 테이블명2 \n(     ) 테이블명1.속성명 = 테이블명2.속성명; 이다. \n괄호 안에 들어갈 단어는?", "ON"],
  ["INNER JOIN의 결과를 구한 후 좌측 항 릴레이션의 어떤 튜플과도 맞지 않는 우측 항의 릴레이션에 있는 튜플들에 NULL 값을 붙여서 INNER JOIN의 결과에 추가하는 JOIN 방법은?", "RIGHT OUTER JOIN"],
  ["RIGHT OUTER JOIN의 표기 형식은 \nSELECT [테이블명1.]속성명, [테이블명2.]속성명, ... \nFROM 테이블명1 RIGHT OUTER JOIN 테이블명2 \n(     ) 테이블명1.속성명 = 테이블명2.속성명; 이다. \n괄호 안에 들어갈 단어는?", "ON"],
  ["OUTER JOIN에서 (     )를 사용하면 INNER JOIN과 동일한 형식으로 사용할 수 있다. INNER JOIN 형식과 동일하게 작성하고 LEFT OUTER JOIN일 때는 조건문의 우측에, RIGHT OUTER JOIN일 때는 조건문의 좌측에 (     )를 붙이는데, 이 때 괄호 안에 들어갈 기호는?", "+"],
  ["LEFT OUTER JOIN과 RIGHT OUTER JOIN을 합쳐 놓은 것으로 INNER JOIN의 결과를 구한 후 좌측 항의 릴레이션의 튜플들에 대해 우측 항의 릴레이션의 어떤 튜플과도 맞지 않는 튜플들에 NULL 값을 붙여서 INNER JOIN의 결과에 추가하고, 우측 항의 릴레이션의 튜플에 대해 좌측 항의 릴레이션의 어떤 튜플과도 맞지 않는 튜플들에 NULL 값을 붙여서 INNER JOIN의 결과에 추가하는 JOIN 방법", "FULL OUTER JOIN"],
  ["FULL OUTER JOIN의 표기 형식은 \nSELECT [테이블명1.]속성명, [테이블명2.]속성명, ... \nFROM 테이블명1 FULL OUTER JOIN 테이블명2 \n(     ) 테이블명1.속성명 = 테이블명2.속성명; 이다. \n괄호 안에 들어갈 단어는?", "ON"]
];

export const QA050 = [
  ["데이터베이스에 저장되어 있는 모든 데이터 개체들에 대한 정보의 집합체. 메타 데이터로 구성되어 있으며, 시스템 카탈로그라도고 함", "데이터 사전", "Data Dictionary"],
  ["데이터 관리를 위한 데이터, 데이터를 위한 데이터를 의미하며 구조 및 통계 정보, 사용자 정보, 테이블의 무결성 제약 조건 정보, 함수, 프로시저 트리거 등에 대한 정보를 관리하는 데이터", "메타 데이터", "Meta Data"],
  ["데이터 사전 테이블에서 My-SQL에서 테이블에 대한 정보를 담는 테이블 이름", "TABLES"],
  ["데이터 사전 테이블에서 Oracle에서 테이블에 대한 정보를 담는 테이블 이름", "TABLES"],
  ["데이터 사전 테이블에서 My-SQL에서 뷰에 대한 정보를 담는 테이블 이름", "VIEWS"],
  ["데이터 사전 테이블에서 Oracle에서 뷰에 대한 정보를 담는 테이블 이름", "VIEWS"],
  ["데이터 사전 테이블에서 My-SQL에서 속성에 대한 정보를 담는 테이블 이름", "COLUMNS"],
  ["데이터 사전 테이블에서 Oracle에서 속성에 대한 정보를 담는 테이블 이름", "TAB_COLUMNS"],
  ["데이터 사전 테이블에서 My-SQL에서 트리거에 대한 정보를 담는 테이블 이름", "TRIGGERS"],
  ["데이터 사전 테이블에서 Oracle에서 트리거에 대한 정보를 담는 테이블 이름", "TRIGGERS"],
  ["My-SQL에서 데이터 사전 테이블을 조회하는 형식은 \n(     ); \nSHOW TABLES; \nSELECT * FROM [테이블]; 이다. 괄호 안에 들어갈 INFORMATION_SCHEMA로 이동하는 명령어는?", "USE INFORMATION_SCHEMA"],
  ["My-SQL에서 데이터 사전 테이블을 조회하는 형식은 \nUSE INFORMATION_SCHEMA; \n(     ); \nSELECT * FROM [테이블]; 이다. 괄호 안에 들어갈 INFORMATION_SCHEMA에 저장된 데이터 사전 테이블들의 목록을 조회하는 명령어는?", "SHOW TABLES"],
  ["Oracle에서 데이터 사전 테이블을 조회하는 형식은 \nSELECT * FROM [영역]_[테이블]; 이다. \n영역에 들어갈 데이터베이스의 모든 객체에 대해 조회 가능하다는 접근 권한을 의미하는 단어는?", "DBA"],
  ["Oracle에서 데이터 사전 테이블을 조회하는 형식은 \nSELECT * FROM [영역]_[테이블]; 이다. \n영역에 들어갈 DBA의 권한 없이 접근할 수 있는 모든 객체에 대해 조회 가능하다는 접근 권한을 의미하는 단어는?", "ALL"],
  ["Oracle에서 데이터 사전 테이블을 조회하는 형식은 \nSELECT * FROM [영역]_[테이블]; 이다. \n영역에 들어갈 현재 자신의 계정이 소유한 객체에 대해 조회 가능하다는 접근 권한을 의미하는 단어는?", "USER"]
];